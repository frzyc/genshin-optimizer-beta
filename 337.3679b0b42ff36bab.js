(()=>{"use strict";var e,t,n={12337:(e,t,n)=>{function a(e,t){if(e&&t)return!Array.isArray(t)&&console.error(t),t.reduce(((e,t)=>null==e?void 0:e[t]),e)}function r(e,t){return Object.fromEntries(e.map(((e,n)=>[e,t(e,n)])))}function s(e,t){return Object.fromEntries(e.map(((e,n)=>t(e,n))))}function o(e,t){return Object.fromEntries(Object.entries(e).map((([e,n],a)=>[e,t(n,e,a)])))}const i=function*(e,t){for(let n=e;n<=t;n++)yield n};function l(e,t){return[...i(e,t)]}function c(e){throw new Error(`Should not reach this with value ${e}`)}u(NaN,{name:"TODO"}),d(1),d(0),u("none");function u(e,t){return"number"==typeof e?{operation:"const",operands:[],type:"number",value:e,info:t}:{operation:"const",operands:[],type:"string",value:e,info:t}}function d(e,t){return e>=Number.MAX_VALUE/100&&(e=1/0),e<=-Number.MAX_VALUE/100&&(e=-1/0),u(e,Object.assign({unit:"%"},t))}function h(e){return e.map((e=>"object"==typeof e?e:u(e)))}function p(e){return"object"!=typeof e?u(e):e}function f(e,t,n){const a=new Set,r=new Set;e.forEach((function e(s){r.has(s)||(a.has(s)?console.error("Found cyclical dependency during formula traversal"):(a.add(s),t(s),s.operands.forEach(e),n(s),a.delete(s),r.add(s)))}))}function m(e,t,n){const a=new Set,r=new Map,s=new Map;function o(e){let i=r.get(e);if(i)return i;i=t(e);let l=s.get(i);return l||(a.has(i)?(console.error("Found cyclical dependency during formula mapping"),u(NaN)):(a.add(i),l=n(function(e){const t=e.operands.map(o);return v(t,e.operands)?e:Object.assign({},e,{operands:t})}(i),e),a.delete(i),r.set(e,l),s.set(i,l),l))}const i=e.map(o);return v(i,e)?e:i}function g(e,t,n){const a=new Map;function r(e,t){let s=a.get(t);s||a.set(t,s=[new Set,new Map]);const[o,i]=s,l=i.get(e);if(l)return l;if(o.has(e))throw new Error("Found cyclical dependency during formula mapping");o.add(e);const c=n(e,t,r);return i.set(e,c),o.delete(e),c}return e.map((e=>r(e,t)))}function v(e,t){return void 0===e?void 0===t:void 0!==t&&(e.length===t.length&&e.every(((e,n)=>e===t[n])))}const b={min:e=>Math.min(...e),max:e=>Math.max(...e),add:e=>e.reduce(((e,t)=>e+t),0),mul:e=>e.reduce(((e,t)=>e*t),1)},w=Object.assign({},b,{res:([e])=>e<0?1-e/2:e>=.75?1/(4*e+1):1-e,sum_frac:e=>e[0]/e.reduce(((e,t)=>e+t)),threshold:([e,t,n,a])=>e>=t?n:a}),x=new Set(Object.keys(b));function y(e){return m(e,(e=>e),(e=>{let t=e;if(x.has(e.operation)){const n=e,{operation:a}=n;let r=!1;const s=n.operands.flatMap((e=>e.operation===a?(r=!0,e.operands):[e]));t=r?Object.assign({},n,{operands:s}):n}return t}))}function k(e){function t(e){const t=new Map;for(const a of e){var n;t.set(a,(null!=(n=t.get(a))?n:0)+1)}return t}const n={common:{counts:new Map,formulas:new Set,operation:"add"}};for(;;){let r;const s={operation:n.common.operation,operands:(a=n.common.counts,[...a].flatMap((([e,t])=>Array(t).fill(e))))},o=new Map;for(const e of Object.keys(b))o.set(e,[]);if(e=m(e,(e=>{if(n.common.formulas.has(e)){const t=e,a=new Map(n.common.counts),r=t.operands.filter((e=>{const t=a.get(e);return!t||(a.set(e,t-1),!1)}));return r.length?(r.push(s),Object.assign({},t,{operands:r})):s}return e}),(e=>{if(!x.has(e.operation))return e;const n=e;if(r){if(r.operation===n.operation){const e=t(n.operands),s=new Map,o=r.counts;let i=0;for(const[t,n]of e.entries()){var a;const e=Math.min(n,null!=(a=o.get(t))?a:0);e?(s.set(t,e),i+=e):s.delete(t)}i>1&&(r.counts=s,r.formulas.add(n))}}else{const e=o.get(n.operation),a=t(n.operands);for(const[t,i]of e){let e=0;const l=new Map;for(const[t,n]of i.entries()){var s;const r=Math.min(n,null!=(s=a.get(t))?s:0);r&&(l.set(t,r),e+=r)}if(e>1){r={counts:l,formulas:new Set([n,t]),operation:n.operation},o.clear();break}}r||e.push([n,a])}return n})),!r)break;n.common=r}var a;return e}function S(e,t,n=(e=>!1)){const r={data:[],processed:new Map},s=new Map([[r,new Map]]),o={data:[t],processed:new Map};return s.set(o,new Map),s.get(r).set(t,o),g(e,o,((e,t,o)=>{var i;const{operation:l}=e,d=(e,t)=>o(e,t),h=(e,t)=>o(e,t);let p;switch(l){case"const":p=e;break;case"add":case"mul":case"max":case"min":const v=w[l],b=[],x=e.operands.filter((e=>{const n=d(e,t);return"const"!==n.operation||(b.push(n.value),!1)})).map((e=>d(e,t))),y=v(b);if(isFinite(y)){if("mul"===l&&0===y){p=u(y);break}}else if("mul"!==l&&("max"!==l||y>0)&&("min"!==l||y<0)){p=u(y);break}y!==v([])&&x.push(u(y)),p=x.length<=1?null!=(i=x[0])?i:u(v([])):{operation:l,operands:x};break;case"res":case"sum_frac":{const n=e.operands.map((e=>d(e,t))),a=w[l];p=n.every((e=>"const"===e.operation))?u(a(n.map((e=>e.value)))):Object.assign({},e,{operands:n});break}case"lookup":{const n=h(e.operands[0],t);if("const"===n.operation){var f;const a=null!=(f=e.table[n.value])?f:e.operands[1];if(a){p=o(a,t);break}}throw new Error(`Unsupported ${l} node while folding`)}case"prio":{const n=e.operands.find((e=>{const n=h(e,t);if("const"!==n.operation)throw new Error(`Unsupported ${l} node while folding`);return void 0!==n.value}));p=n?h(n,t):u(void 0);break}case"small":{var m;let n;for(const a of e.operands){var g;const e=h(a,t);if("const"!==e.operation)throw new Error(`Unsupported ${l} node while folding`);(void 0===(null==(g=n)?void 0:g.value)||void 0!==e.value&&e.value<n.value)&&(n=e)}p=null!=(m=n)?m:u(void 0);break}case"match":{const[n,a,r,s]=e.operands.map((e=>o(e,t)));if("const"!==n.operation||"const"!==a.operation)throw new Error(`Unsupported ${l} node while folding`);p=n.value===a.value?r:s;break}case"threshold":{const[n,a,r,s]=e.operands.map((e=>o(e,t)));p="const"===r.operation&&"const"===s.operation&&r.value===s.value?r:"const"===n.operation&&"const"===a.operation?n.value>=a.value?r:s:Object.assign({},e,{operands:[n,a,r,s]});break}case"subscript":{const n=d(e.operands[0],t);if("const"!==n.operation)throw new Error("Found non-constant subscript node while folding");p=u(e.list[n.value]);break}case"read":{const r=t.data.map((t=>a(t,e.path))).filter((e=>e));if(0===r.length)if(n(e)){const{accu:t}=e;p=void 0===t||"small"===t?"string"===e.type?u(void 0):u(NaN):u(w[t]([]))}else p=e;else p=void 0===e.accu||1===r.length?o(r[r.length-1],t):o({operation:e.accu,operands:r},t);break}case"data":{e.reset&&(t=r);const n=s.get(t);let a=n.get(e.data);a||(a={data:[...t.data,e.data],processed:new Map},s.set(a,new Map),n.set(e.data,a)),p=o(e.operands[0],a);break}default:c(l)}return p.info&&(p=Object.assign({},p),delete p.info),p}))}n(15735),n(6886),n(39529);const O=["Albedo","Alhaitham","Aloy","Amber","AratakiItto","Barbara","Beidou","Bennett","Candace","Chongyun","Collei","Cyno","Diluc","Diona","Dori","Eula","Faruzan","Fischl","Ganyu","Gorou","HuTao","Jean","KaedeharaKazuha","Kaeya","KamisatoAyaka","KamisatoAyato","Keqing","Klee","KujouSara","KukiShinobu","Layla","Lisa","Mona","Nahida","Nilou","Ningguang","Noelle","Qiqi","RaidenShogun","Razor","Rosaria","SangonomiyaKokomi","Sayu","Shenhe","ShikanoinHeizou","Sucrose","Tartaglia","Thoma","Tighnari","Venti","Wanderer","Xiangling","Xiao","Xingqiu","Xinyan","YaeMiko","Yanfei","Yaoyao","Yelan","Yoimiya","YunJin","Zhongli"],j=["TravelerAnemo","TravelerGeo","TravelerElectro","TravelerDendro"];const M=["AmenomaKageuchi","AquilaFavonia","BlackcliffLongsword","CinnabarSpindle","CoolSteel","KagotsurubeIsshin","DarkIronSword","DullBlade","FavoniusSword","FesteringDesire","FilletBlade","FreedomSworn","HaranGeppakuFutsu","HarbingerOfDawn","IronSting","KeyOfKhajNisut","LightOfFoliarIncision","LionsRoar","MistsplitterReforged","PrimordialJadeCutter","PrototypeRancour","RoyalLongsword","SacrificialSword","SapwoodBlade","SilverSword","SkyriderSword","SkywardBlade","SummitShaper","SwordOfDescension","TheAlleyFlash","TheBlackSword","TheFlute","ToukabouShigure","TravelersHandySword","XiphosMoonlight"],F=["Akuoumaru","BlackcliffSlasher","BloodtaintedGreatsword","DebateClub","FavoniusGreatsword","FerrousShadow","ForestRegalia","KatsuragikiriNagamasa","LithicBlade","LuxuriousSeaLord","MakhairaAquamarine","OldMercsPal","PrototypeArchaic","Rainslasher","RedhornStonethresher","RoyalGreatsword","SacrificialGreatsword","SerpentSpine","SkyriderGreatsword","SkywardPride","SnowTombedStarsilver","SongOfBrokenPines","TheBell","TheUnforged","WasterGreatsword","Whiteblind","WhiteIronGreatsword","WolfsGravestone"],E=["BeginnersProtector","BlackcliffPole","BlackTassel","CalamityQueller","CrescentPike","Deathmatch","DragonsBane","DragonspineSpear","EngulfingLightning","FavoniusLance","Halberd","IronPoint","KitainCrossSpear","LithicSpear","MissiveWindspear","Moonpiercer","PrimordialJadeWingedSpear","PrototypeStarglitter","RoyalSpear","SkywardSpine","StaffOfHoma","StaffOfTheScarletSands","TheCatch","VortexVanquisher","WavebreakersFin","WhiteTassel"],T=["AlleyHunter","AmosBow","AquaSimulacra","BlackcliffWarbow","CompoundBow","ElegyForTheEnd","EndOfTheLine","FadingTwilight","FavoniusWarbow","Hamayumi","HuntersBow","HuntersPath","KingsSquire","Messenger","MitternachtsWaltz","MouunsMoon","PolarStar","Predator","PrototypeCrescent","RavenBow","RecurveBow","RoyalBow","Rust","SacrificialBow","SeasonedHuntersBow","SharpshootersOath","SkywardHarp","Slingshot","TheStringless","TheViridescentHunt","ThunderingPulse","WindblumeOde"],$=["ApprenticesNotes","AThousandFloatingDreams","BlackcliffAgate","DodocoTales","EmeraldOrb","EverlastingMoonglow","EyeOfPerception","FavoniusCodex","Frostbearer","FruitOfFulfillment","HakushinRing","KagurasVerity","LostPrayerToTheSacredWinds","MagicGuide","MappaMare","MemoryOfDust","OathswornEye","OtherworldlyStory","PocketGrimoire","PrototypeAmber","RoyalGrimoire","SacrificialFragments","SkywardAtlas","SolarPearl","TheWidsith","ThrillingTalesOfDragonSlayers","TulaytullahsRemembrance","TwinNephrite","WanderingEvenstar","WineAndSong"],A=["flower","plume","sands","goblet","circlet"],B=["TravelerAnemo","TravelerGeo","TravelerElectro","TravelerDendro"];function N(e,t,n,a,r,s){let o=s;const i={pruneNodeRange:!0},l={pruneNodeRange:!0},c={reaffine:!0},u={pruneOrder:!0,pruneArtRange:!0,pruneNodeRange:!0};let d=0;for(;Object.values(o).some((e=>e))&&d++<20;){if(o.pruneOrder){delete o.pruneOrder;const e=C(n,a,r);n!==e&&(n=e,o=Object.assign({},o,i))}if(o.pruneArtRange){delete o.pruneArtRange;const a=D(e,n,t);n!==a&&(n=a,o=Object.assign({},o,l))}if(o.pruneNodeRange){delete o.pruneNodeRange;const t=P(e,n);e!==t&&(e=t,o=Object.assign({},o,c))}if(o.reaffine){delete o.reaffine;const{nodes:t,arts:a}=R(e,n);e===t&&n===a||(e=t,n=a,o=Object.assign({},o,u))}}return{nodes:e,arts:n}}function R(e,t,n=!1){const a=new Set,s=new Set;function i(e,t){t?a.add(e):e.operands.forEach((e=>a.has(e)&&s.add(e)))}const l=new Set;if(f(e,(e=>{}),(e=>{const{operation:t}=e;switch(t){case"read":l.add(e.path[1]),i(e,!0);break;case"add":i(e,e.operands.every((e=>a.has(e))));break;case"mul":{const t=e.operands.filter((e=>"const"!==e.operation));i(e,0===t.length||1===t.length&&a.has(t[0]));break}case"const":i(e,!0);break;case"res":case"threshold":case"sum_frac":case"max":case"min":i(e,!1);break;default:c(t)}})),[...s].every((({operation:e})=>"read"===e||"const"===e))&&Object.keys(t.base).length===l.size)return{nodes:e,arts:t};let d=-1;function h(){for(;l.has(""+ ++d););return`${d}`}e.forEach((e=>a.has(e)&&s.add(e)));const p=[...s].filter((e=>"const"!==e.operation)),g=new Map(p.map((e=>{return[e,n||"read"!==e.operation||"dyn"!==e.path[0]?Object.assign({},(t=["dyn",`${h()}`],{operation:"read",operands:[],path:t,info:a,type:"number"}),{accu:"add"}):e];var t,a})));function v(e){const t=S([...g.keys()],{dyn:o(e,(e=>u(e)))},(e=>!0));return Object.fromEntries([...g.values()].map(((e,n)=>[e.path[1],t[n].value])))}const b={nodes:e=m(e,(e=>{var t;return null!=(t=g.get(e))?t:e}),(e=>e)),arts:{base:v(t.base),values:r(A,(e=>t.values[e].map((({id:e,set:t,values:n})=>({id:e,set:t,values:v(n)})))))}},w=Object.entries(v({}));for(const r of Object.values(b.arts.values))for(const{values:e}of r)for(const[t,n]of w)e[t]-=n;return b}function C(e,t,n){var a;let s=!1;const o=!(null!=(a=n.rainbow)&&a.length),i=Object.keys(e.base),l=new Set(Object.entries(n).filter((([e,t])=>t.length)).map((([e])=>e))),c=new Set(Object.entries(n).filter((([e,t])=>t.includes(2)&&!t.includes(4))).map((([e])=>e))),u=r(A,(n=>{const a=e.values[n],r=a.filter((e=>{let n=0;return a.every((a=>{const r=i.every((t=>{var n,r;return(null!=(n=a.values[t])?n:0)>=(null!=(r=e.values[t])?r:0)})),s=i.some((t=>{var n,r;return(null!=(n=a.values[t])?n:0)>(null!=(r=e.values[t])?r:0)})),u=r&&(s||a.id>e.id),d=o&&!l.has(a.set)&&!c.has(e.set)||e.set===a.set;return u&&d&&n++,n<t}))}));return r.length!==a.length&&(s=!0),r}));return s?{base:e.base,values:u}:e}function D(e,t,n){const a=Object.fromEntries(Object.entries(t.base).map((([e,t])=>[e,{min:t,max:t}]))),s={arts:t};for(;;){const t=r(A,(e=>U(s.arts.values[e]))),o=r(A,(e=>K(Object.entries(t).map((t=>t[0]===e?a:t[1])).filter((e=>e)))));let i=!1;const l=r(A,(t=>{const a=s.arts.values[t].filter((a=>{const r=K([U([a]),o[t]]),s=W(e,r);return e.every(((e,t)=>{var a;return s.get(e).max>=(null!=(a=n[t])?a:-1/0)}))}));return a.length!==s.arts.values[t].length&&(i=!0),a}));if(!i)break;s.arts={base:s.arts.base,values:l}}return s.arts}function P(e,t){const n=W(e,K([Object.fromEntries(Object.entries(t.base).map((([e,t])=>[e,{min:t,max:t}]))),...Object.values(t.values).map((e=>U(e)))]));return m(e,(e=>{{const{min:t,max:a}=n.get(e);if(t===a)return u(t)}const{operation:t}=e,a=e.operands.map((e=>n.get(e)));switch(t){case"threshold":{const[t,n,r,s]=a;if(t.min>=n.max)return e.operands[2];if(t.max<n.min)return e.operands[3];if(r.max===r.min&&s.max===s.min&&r.min===s.min&&isFinite(r.min))return u(r.max);break}case"min":{const t=e.operands.filter(((e,t)=>{const n=a[t];return a.every(((e,t)=>n.min<=e.max))}));if(t.length<a.length)return function(...e){return{operation:"min",operands:h(e)}}(...t);break}case"max":{const t=e.operands.filter(((e,t)=>{const n=a[t];return a.every((e=>n.max>=e.min))}));if(t.length<a.length)return function(...e){return{operation:"max",operands:h(e)}}(...t);break}}return e}),(e=>e))}function K(e){const t={};return e.forEach((e=>{Object.entries(e).forEach((([e,n])=>{t[e]?(t[e].min+=n.min,t[e].max+=n.max):t[e]=Object.assign({},n)}))})),t}function U(e){const t={};return e.length&&(Object.keys(e[0].values).filter((t=>e.every((e=>e.values[t])))).forEach((n=>t[n]={min:e[0].values[n],max:e[0].values[n]})),e.forEach((({values:e})=>{for(const[n,a]of Object.entries(e))t[n]?(t[n].max<a&&(t[n].max=a),t[n].min>a&&(t[n].min=a)):t[n]={min:0,max:a}}))),t}function W(e,t){const n=new Map;return f(e,(e=>{}),(e=>{var a;const{operation:r}=e,s=e.operands.map((e=>n.get(e)));let o;switch(r){case"read":if("dyn"!==e.path[0])throw new Error(`Found non-dyn path ${e.path} while computing range`);o=null!=(a=t[e.path[1]])?a:{min:0,max:0};break;case"const":o=G([e.value]);break;case"add":case"min":case"max":o={min:w[r](s.map((e=>e.min))),max:w[r](s.map((e=>e.max)))};break;case"res":o={min:w[r]([s[0].max]),max:w[r]([s[0].min])};break;case"mul":o=s.reduce(((e,t)=>G([e.min*t.min,e.min*t.max,e.max*t.min,e.max*t.max])));break;case"threshold":o=s[0].min>=s[1].max?s[2]:s[0].max<s[1].min?s[3]:G([],[s[2],s[3]]);break;case"sum_frac":{const[e,t]=s,n={min:e.min+t.min,max:e.max+t.max};o=n.min<=0&&n.max>=0?e.min<=0&&e.max>=0?{min:NaN,max:NaN}:{min:-1/0,max:1/0}:G([e.min/n.min,e.min/n.max,e.max/n.min,e.max/n.max]);break}default:c(r)}n.set(e,o)})),n}function G(e,t=[]){const n=Math.max(...e,...t.map((e=>e.max)));return{min:Math.min(...e,...t.map((e=>e.min))),max:n}}function L(e,t){return{base:e.base,values:r(A,(n=>{const a=t[n];switch(a.kind){case"id":return e.values[n].filter((e=>a.ids.has(e.id)));case"exclude":return e.values[n].filter((e=>!a.sets.has(e.set)));case"required":return e.values[n].filter((e=>a.sets.has(e.set)))}}))}}function q(e){return A.reduce(((t,n)=>t*e.values[n].length),1)}function z(e){return new Set(null!=e&&e.includes(2)?e.includes(4)?[0,1]:[0,1,4,5]:null!=e&&e.includes(4)?[0,1,2,3]:[0,1,2,3,4,5])}function*H(e,t){const n=[...new Set(t)],a=z(e.rainbow);let s=[];function i(e,t){if(!l(t+1,4).some((t=>5!==e[t])))return(e=[...e])[t]=5,e.reduce(((e,t)=>6*e+t),0)}!function e(t,n,r){if(5!==t.length){for(const a of n)e([...t,a],n,r.filter((e=>e!==a)));e([...t,t.length],new Set([...n,t.length]),[...r,t.length])}else a.has(r.length)&&s.push(t)}([0],new Set([0]),[0]);for(let r=4;r>=0;r--){const e=new Map;for(const t of s){var c;const n=i(t,r);void 0!==n&&e.set(n,(null!=(c=e.get(n))?c:new Set(t.slice(0,r)).size+1)-1)}for(const[t,n]of e.entries())if(0===n){const e=[...s.find((e=>i(e,r)===t))];e[r]=5,s=s.filter((e=>i(e,r)!==t)),s.push(e)}}const u={kind:"exclude",sets:new Set},d=r(A,(e=>u)),h=Object.assign({},o(e,(e=>0)),r(n,(e=>0))),p=o(e,z);function*f(e){const t=new Set;let a=[],r=[];for(const n of e)a.push([]),5===n?r.push(a.length-1):a[n].push(a.length-1);a=a.filter((e=>e.length)).sort(((e,t)=>t.length-e.length));let s=r.length;function*o(e){const t=r.length-e,a=[],s=[],i=[];let c=0;for(const r of n){const e=p[r],n=h[r];e&&(l(1,t).every((t=>!e.has(n+t)))?i.push(r):e.has(n)?l(0,t).some((t=>!e.has(n+t)))&&a.push(r):(c+=[...e].find((e=>e>n))-n,s.push(r)))}if(!(c>t))if(e!==r.length)if(c!==t){for(const t of[...a,...s])h[t]++,d[A[r[e]]]={kind:"required",sets:new Set([t])},yield*o(e+1),h[t]--;d[A[r[e]]]={kind:"exclude",sets:new Set([...s,...i,...a])},yield*o(e+1)}else for(const n of s)h[n]++,d[A[r[e]]]={kind:"required",sets:new Set([n])},yield*o(e+1),h[n]--;else yield Object.assign({},d)}yield*function*e(r){if(r===a.length)return yield*o(0);for(const o of n){if(t.has(o))continue;const n=a[r].length,c=p[o];let u=0;var i;if(c&&!c.has(n))if(u=(null!=(i=l(n+1,5).find((e=>c.has(e))))?i:6)-n,u>s)continue;t.add(o),h[o]=a[r].length,a[r].forEach((e=>d[A[e]]={kind:"required",sets:new Set([o])})),s-=u,yield*e(r+1),s+=u,h[o]=0,t.delete(o)}}(0)}for(const r of s)yield*f(r)}class I{constructor({arts:e,optimizationTarget:t,filters:n,maxBuilds:a},r){this.min=void 0,this.nodes=void 0,this.arts=void 0,this.maxBuilds=void 0,this.filters=[],this.interim=void 0,this.firstUncalculated=0,this.callback=void 0,this.arts=e,this.min=[-1/0,...n.map((e=>e.min))],this.nodes=[t,...n.map((e=>e.value))],this.callback=r,this.maxBuilds=a,Y(this.nodes,e)}addFilter(e){const t=L(this.arts,e),n=q(t);n&&this.filters.push({nodes:this.nodes,arts:t,maxConts:[],approxs:[],age:0,count:n})}split(e,t){for(e>this.min[0]&&(this.min[0]=e,this.firstUncalculated=0,this.filters.forEach((e=>delete e.calculated))),this.firstUncalculated<this.filters.length&&this.calculateFilter(this.firstUncalculated++);this.filters.length;){const e=this.getApproxFilter(),{arts:n,count:a}=e;if(this.reportInterim(!1),a){if(a<=t)return this.reportInterim(!0),o(n.values,(e=>({kind:"id",ids:new Set(e.map((e=>e.id)))})));this.splitOldFilter(e)}}this.reportInterim(!0)}reportInterim(e=!1){this.interim&&(this.interim.skipped>1e6||!0===e)&&(this.callback(this.interim),this.interim=void 0)}splitOldFilter({nodes:e,arts:t,approxs:n,age:a}){const r=o(t.values,(e=>{var t,a;const r=e.map((e=>({art:e,cont:n[0].conts[e.id]}))).sort((({cont:e},{cont:t})=>t-e)),s=null!=(t=null==(a=r[r.length-1])?void 0:a.cont)?t:0;let o=r.reduce(((e,{cont:t})=>e+t),-s*r.length)/3;const i=Math.max(1,r.findIndex((({cont:e})=>(o-=e-s)<=0))),l=r.splice(i).map((({art:e})=>e)),c=r.map((({art:e})=>e));return{high:{arts:c,maxConts:n.map((e=>V(c,e)))},low:{arts:l,maxConts:n.map((e=>V(l,e)))}}})),s=Object.keys(r),{filters:i}=this,l={},c={};!function u(d){if(!s.length){const r=n.map(((e,t)=>o(c,(e=>e[t])))),s={base:t.base,values:Object.assign({},l)};return void i.push({nodes:e,arts:s,maxConts:r,approxs:n,age:a+1,count:d})}const h=s.pop(),{high:p,low:f}=r[h];f.arts.length&&(l[h]=f.arts,c[h]=f.maxConts,u(d*f.arts.length)),p.arts.length&&(l[h]=p.arts,c[h]=p.maxConts,u(d*p.arts.length)),s.push(h)}(1)}getApproxFilter(){return this.calculateFilter(this.filters.length-1),this.firstUncalculated>this.filters.length&&(this.firstUncalculated=this.filters.length),this.filters.pop()}calculateFilter(e){let{nodes:t,arts:n,maxConts:a,approxs:r,age:i,count:l,calculated:c}=this.filters[e];if(c)return;(i<3||i%5==2)&&(({nodes:t,arts:n}=N(t,this.min,n,this.maxBuilds,{},{pruneNodeRange:!0})),Object.values(n.values).every((e=>e.length))&&(r=function(e,t){return Y(e,t).map((e=>({base:_(t.base,e,e.$c),conts:s(Object.values(t.values).flat(),(t=>[t.id,_(t.values,e,0)]))})))}(t,n),a=r.map((e=>o(n.values,(t=>V(t,e)))))));const u=a.map(((e,t)=>Object.values(e).reduce(((e,t)=>e+t),r[t].base-this.min[t]))),d=o(n.values,((e,t)=>{const n=u.map(((e,n)=>a[n][t]-e));return e.filter((({id:e})=>r.every((({conts:t},a)=>t[e]>=n[a]))))}));n={base:n.base,values:d};const h=q(n);h!==l&&(this.interim?this.interim.skipped+=l-h:this.interim={command:"interim",buildValues:void 0,tested:0,failed:0,skipped:l-h}),this.filters[e]={nodes:t,arts:n,maxConts:a,approxs:r,age:i,count:h,calculated:!0}}}function V(e,t){return Math.max(...e.map((({id:e})=>t.conts[e])))}function _(e,t,n){return Object.entries(e).reduce(((e,[n,a])=>{var r;return e+(null!=(r=t[n])?r:0)*a}),n)}function X(...e){const t={};for(const[a,r]of e)for(const[e,s]of Object.entries(r)){var n;t[e]=(null!=(n=t[e])?n:0)+a*s}return t}function Y(e,t){const n=X([1,t.base],...Object.values(t.values).map((e=>[1/e.length,X(...e.map((e=>[1,e.values])))]))),a=e=>_(n,e,e.$c),r=new Map;f(e,(e=>{const{operation:t}=e;switch("mul"===t&&r.set(e,{min:NaN,max:NaN}),t){case"mul":case"min":case"max":case"threshold":case"res":case"sum_frac":e.operands.forEach((e=>r.set(e,{min:NaN,max:NaN})))}}),(e=>e));const s=W([...r.keys()],function(e){return K([Object.fromEntries(Object.entries(e.base).map((([e,t])=>[e,{min:t,max:t}]))),...Object.values(e.values).map((e=>U(e)))])}(t));for(const[c,d]of s.entries())r.set(c,d);function o(e,t,n,a){return X([1,{$c:n-e*t}],[e,a])}function i(e,t,n,a,r,s){return Math.abs(e-n)<1e-10?{$c:s?Math.max(t,a):Math.min(t,a)}:o((a-t)/(n-e),e,t,r)}const l="u",u="l";return g(e,l,((e,t,n)=>{const{operation:s}=e,d=(e,a=t)=>n(e,a),f=t===l?u:l;if("o"===t){const{min:t,max:n}=r.get(e);if(t<0&&n>0)throw new J("Zero-crossing",s);return d(e,n<=0?u:l)}switch(s){case"const":return{$c:e.value};case"read":return{$c:0,[e.path[1]]:1};case"add":return X(...e.operands.map((e=>[1,d(e)])));case"min":case"max":{const n=w[s],a=e.operands.filter((e=>"const"!==e.operation)),[o]=a;if(1!==a.length)throw new J("Multivariate",s);const c=d(o),h=n(e.operands.filter((e=>"const"===e.operation)).map((e=>e.value)));if("max"===s&&t===u||"min"===s&&t===l)return c;const{min:p,max:f}=r.get(o);return i(p,n([p,h]),f,n([f,h]),c,t===l)}case"res":{if(t!==l)throw new J("Unsupported direction",s);const n=w[s],[a]=e.operands,{min:o,max:c}=r.get(a),u=d(a,f);return o<0&&c<1.75?X([1,{$c:1}],[-.5,u]):i(o,n([o]),c,n([c]),u,t===l)}case"sum_frac":{if(t!==l)throw new J("Unsupported direction",s);const[n,a]=e.operands;if("const"!==a.operation)throw new J("Non-constant node",s);const i=d(n),c=a.value,{min:u,max:h}=r.get(n),p=Math.sqrt((u+c)*(h+c));if(u<=-c)throw new J("Unsupported pattern",s);return o(c/(c+p)/(c+p),p,p/(p+c),i)}case"threshold":{const[n,a,i,c]=e.operands;if("const"!==c.operation||"const"!==a.operation)throw new J("Non-constant node",s);if("const"!==i.operation){if(0!==c.value)throw new J("Unsupported pattern",s);const e=(m=a,g=1,v=c,{operation:"threshold",operands:[p(n),p(m),p(g),p(v)],info:b}),t=function(...e){return{operation:"mul",operands:h(e)}}(e,i),{min:o,max:l}=r.get(i);return r.set(e,{min:0,max:1}),r.set(t,{min:Math.min(o,0),max:Math.max(l,0)}),d(t)}const{min:u,max:w}=r.get(n),x=a.value,y=i.value,k=c.value,S=y>k==(t===l);return o((y-k)/(S?x-u:w-x),x,S?y:k,d(n,y>k?t:f))}case"mul":{const{min:n,max:o}=r.get(e);if(n<0&&o>0)throw new J("Zero-crossing",s);if(n<0&&t!==u||o>0&&t!==l)throw new J("Unsupported direction",s);const i=[...e.operands],c=[];let h=1;for(;i.length;){const e=i.pop();"mul"===e.operation?i.push(...e.operands):"const"===e.operation?h*=e.value:c.push(e)}const p=c.map((e=>d(e,"o"))),f=c.map((e=>r.get(e))),m=p.map(a),g=m.reduce(((e,t,n)=>e+(t>=0?f[n].max:f[n].min)/t),0),v=m.reduce(((e,t)=>e*g*t/p.length),h/g);return X(...p.map(((e,t)=>[v/m[t],e])))}default:c(s)}var m,g,v,b}))}class J extends Error{constructor(e,t){super(`Found ${e} in ${t} node when generating polynomial upper bound`)}}class Z{constructor({arts:e,optimizationTarget:t,filters:n,plotBase:a,maxBuilds:r},s){this.builds=[],this.buildValues=void 0,this.plotData=void 0,this.threshold=-1/0,this.maxBuilds=void 0,this.min=void 0,this.arts=void 0,this.nodes=void 0,this.callback=void 0,this.interimReport=(e,t=!1)=>{this.refresh(t),this.callback(Object.assign({command:"interim",buildValues:this.buildValues},e)),this.buildValues=void 0,e.tested=0,e.failed=0,e.skipped=0},this.arts=e,this.min=n.map((e=>e.min)),this.maxBuilds=r,this.callback=s,this.nodes=n.map((e=>e.value)),this.nodes.push(t),a&&(this.plotData={},this.nodes.push(a)),this.nodes=function(e,t,n=(e=>!1)){let a=S(e,t,n);return a=y(a),k(a)}(this.nodes,{},(e=>!1))}compute(e,t){this.threshold>e&&(this.threshold=e);const{min:n,interimReport:a}=this,r=this;let s=L(this.arts,t);const o=q(s),i=this.builds.length;let l=this.nodes;({nodes:l,arts:s}=N(l,n,s,this.maxBuilds,{},{pruneArtRange:!0,pruneNodeRange:!0}));const u=Object.values(s.values).sort(((e,t)=>e.length-t.length)),d=function(e,t,n,a){let r='\n"use strict";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n}\nconst x0=0',s=1;const o=new Map;return f(e,(e=>{}),(e=>{const{operation:i,operands:l}=e,u="x"+s++,d=l.map((e=>o.get(e)));switch(o.set(e,u),i){case"read":{const s=n(e);let o=new Array(a).fill(null).map(((e,t)=>`(b[${t}].values["${s}"] ?? 0)`));t[s]&&0!==t[s]&&(o=[t[s].toString(),...o]),r+=`,${u}=${o.join("+")}`;break}case"const":o.set(e,`(${e.value})`);break;case"add":case"mul":r+=`,${u}=${d.join("add"===i?"+":"*")}`;break;case"min":case"max":r+=`,${u}=Math.${i}(${d})`;break;case"threshold":{const[e,t,n,a]=d;r+=`,${u}=(${e}>=${t})?${n}:${a}`;break}case"res":r+=`,${u}=res(${d[0]})`;break;case"sum_frac":r+=`,${u}=${d[0]}/(${d[0]}+${d[1]})`;break;default:c(i)}})),r+=`;\nreturn [${e.map((e=>o.get(e)))}]`,new Function("b",r)}(l,s.base,(e=>e.path[1]),u.length),h=Array(u.length),p={tested:0,failed:0,skipped:o-q(s)};!function e(t){if(t<0){const e=d(h);if(n.every(((t,n)=>t<=e[n]))){const t=e[n.length],{builds:a,plotData:s}=r;let o;if(t>=r.threshold&&(o={value:t,artifactIds:h.map((e=>e.id)).filter((e=>e))},a.push(o)),s){const a=e[n.length+1];(!s[a]||s[a].value<t)&&(o||(o={value:t,artifactIds:h.map((e=>e.id)).filter((e=>e))}),o.plot=a,s[a]=o)}}else p.failed+=1}else u[t].forEach((n=>{h[t]=n,e(t-1)})),0===t&&(p.tested+=u[0].length,p.tested>65536&&a(p))}(u.length-1),a(p,this.builds.length>i)}refresh(e){var t;const{maxBuilds:n}=this;var a;(Object.keys(null!=(t=this.plotData)?t:{}).length>=1e5&&(this.plotData=function(e){let t=.01,n=new Set(e.flatMap((e=>Object.values(e).map((e=>Math.round(e.plot/t))))));for(;n.size>1500;)t*=2,n=new Set([...n].map((e=>Math.round(e/2))));const a={};for(const r of e)for(const e of Object.values(r)){const n=Math.round(e.plot/t)*t;(!a[n]||a[n].value<e.value)&&(a[n]=e)}return a}([this.plotData])),this.builds.length>=1e3||e)&&(this.builds=this.builds.sort(((e,t)=>t.value-e.value)).slice(0,n),this.buildValues=this.builds.map((e=>e.value)),this.threshold=Math.max(this.threshold,null!=(a=this.buildValues[n-1])?a:-1/0))}}class Q{constructor({arts:e},t){this.arts=void 0,this.filters=[],this.arts=e}addFilter(e){this.filters.push(e)}split(e,t){for(;this.filters.length;){const e=this.filters.pop();if(q(L(this.arts,e))<=t)return e;ee(this.arts,e,t).forEach((e=>this.addFilter(e)))}}}function ee(e,t,n){const a=L(e,t),r=A.map((e=>({slot:e,sets:new Set(a.values[e].map((e=>e.set)))}))).filter((({sets:e})=>e.size>1));if(!r.length)return function(e,t,n){const a=L(e,t),r=q(a),s=A.map((e=>({slot:e,length:a.values[e].length}))).filter((e=>e.length>1)),{slot:o,length:i}=s.reduce(((e,t)=>e.length<t.length?e:t)),l=Math.ceil(r/n),c=Math.min(l,i),u=Array(c).fill(0).map((e=>new Set));return a.values[o].forEach((({id:e},t)=>u[t%c].add(e))),u.map((e=>Object.assign({},t,{[o]:{kind:"id",ids:e}})))}(a,t,n);const{sets:s,slot:o}=r.reduce(((e,t)=>e.sets.size<t.sets.size?e:t));return[...s].map((e=>Object.assign({},t,{[o]:{kind:"required",sets:new Set([e])}})))}let te,ne,ae;onmessage=({data:e})=>{const{command:t}=e;let n;switch(t){case"setup":{te=e.id;const t=`split${te}`,r=`compute${te}`;try{ne=new I(e,(e=>postMessage(Object.assign({id:te,source:t},e))))}catch(a){ne=new Q(e,(e=>postMessage(Object.assign({id:te,source:t},e))))}ae=new Z(e,(e=>postMessage(Object.assign({id:te,source:r},e)))),n={command:"iterate"};break}case"split":e.filter&&ne.addFilter(e.filter);n={command:"split",filter:ne.split(e.threshold,e.minCount)};break;case"iterate":{const{threshold:t,filter:a}=e;ae.compute(t,a),n={command:"iterate"};break}case"finalize":{ae.refresh(!0);const{builds:e,plotData:t}=ae;n={command:"finalize",builds:e,plotData:t};break}case"count":{const{exclusion:t}=e,a=ae.arts,r=function*(e,t){const n=o(t.values,(e=>new Set(e.map((e=>e.set)))));e:for(const a of e){for(const[e,t]of Object.entries(a)){const a=n[e];switch(t.kind){case"required":if([...t.sets].every((e=>!a.has(e))))continue e;break;case"exclude":if([...a].every((e=>t.sets.has(e))))continue e}}yield a}}(H(t,[...new Set(Object.values(a.values).flatMap((e=>e.map((e=>e.set)))))]),a),s=e.arts.map((e=>0));for(const n of r)e.arts.forEach(((e,t)=>s[t]+=q(L(e,n))));n={command:"count",counts:s};break}default:c(t)}postMessage(Object.assign({id:te},n))}}},a={};function r(e){var t=a[e];if(void 0!==t)return t.exports;var s=a[e]={exports:{}};return n[e](s,s.exports,r),s.exports}r.m=n,r.x=()=>{var e=r.O(void 0,[531],(()=>r(12337)));return e=r.O(e)},e=[],r.O=(t,n,a,s)=>{if(!n){var o=1/0;for(u=0;u<e.length;u++){for(var[n,a,s]=e[u],i=!0,l=0;l<n.length;l++)(!1&s||o>=s)&&Object.keys(r.O).every((e=>r.O[e](n[l])))?n.splice(l--,1):(i=!1,s<o&&(o=s));if(i){e.splice(u--,1);var c=a();void 0!==c&&(t=c)}}return t}s=s||0;for(var u=e.length;u>0&&e[u-1][2]>s;u--)e[u]=e[u-1];e[u]=[n,a,s]},r.f={},r.e=e=>Promise.all(Object.keys(r.f).reduce(((t,n)=>(r.f[n](e,t),t)),[])),r.u=e=>e+".90a3a02ef4ac00d5.js",r.miniCssF=e=>{},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e;if("string"==typeof import.meta.url&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=e})(),(()=>{var e={337:1};r.f.i=(t,n)=>{e[t]||importScripts(r.p+r.u(t))};var t=self.webpackChunk=self.webpackChunk||[],n=t.push.bind(t);t.push=t=>{var[a,s,o]=t;for(var i in s)r.o(s,i)&&(r.m[i]=s[i]);for(o&&o(r);a.length;)e[a.pop()]=1;n(t)}})(),t=r.x,r.x=()=>r.e(531).then(t);r.x()})();